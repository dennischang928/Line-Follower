"use strict";
// notes:
// done doesnt seem to ever be true?
// want to be able to specify pipelines of decoders
// ie linedecoder or just standard decoder
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserSerial = void 0;
var defaultSerialOptions = {
    baudRate: 115200,
    dataBits: 8,
    stopBits: 1,
    parity: "none",
    bufferSize: 255,
    flowControl: "none",
};
var defaultSerialFilters = {};
var BrowserSerial = /** @class */ (function () {
    function BrowserSerial(serialOptions, serialFilters) {
        this.serialOptions = __assign(__assign({}, defaultSerialOptions), serialOptions);
        this.serialFilters = __assign(__assign({}, defaultSerialFilters), serialFilters);
        this.EOF = "\n";
        this.port = null;
        this.encoder = new TextEncoderStream();
        this.decoder = new TextDecoderStream("utf-8");
        this.lineTransformer = new TransformStream(new LineBreakTransformer());
        // port reads from encoder.readable, i write to encoder.writable
        this.writeToStream = this.encoder.writable;
        // port writes to decoder.writable, i read from decoder.readable
        this.readTransformers = [this.decoder];
        this.readFromStream = this.decoder.readable;
        if (this.EOF === "\n") {
            this.readTransformers.push(this.lineTransformer);
            this.readFromStream = this.lineTransformer.readable;
        }
        this.reader = null;
    }
    BrowserSerial.prototype.connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, pipeReducer;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this;
                        if (!this.serialFilters) return [3 /*break*/, 2];
                        return [4 /*yield*/, navigator.serial.requestPort(this.serialFilters)];
                    case 1:
                        _b = _c.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, navigator.serial.requestPort()];
                    case 3:
                        _b = _c.sent();
                        _c.label = 4;
                    case 4:
                        _a.port = _b;
                        return [4 /*yield*/, this.port.open(this.serialOptions)];
                    case 5:
                        _c.sent();
                        pipeReducer = function (accumulator, currentValue) { return accumulator.pipeThrough(currentValue); };
                        this.readTransformers.reduce(pipeReducer, this.port.readable); //.pipeTo(writable)
                        this.encoder.readable.pipeTo(this.port.writable);
                        return [2 /*return*/];
                }
            });
        });
    };
    BrowserSerial.prototype.disconnect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.reader) return [3 /*break*/, 2];
                        // cancel the reader
                        return [4 /*yield*/, this.reader.cancel()];
                    case 1:
                        // cancel the reader
                        _a.sent();
                        //   await this.inDone.catch(() => {});
                        this.reader = null;
                        _a.label = 2;
                    case 2:
                        if (!this.writeToStream) return [3 /*break*/, 4];
                        // cancel the writer
                        return [4 /*yield*/, this.writeToStream.getWriter().close()];
                    case 3:
                        // cancel the writer
                        _a.sent();
                        //   await this.outDone;
                        this.writeToStream = null;
                        _a.label = 4;
                    case 4: 
                    // close the port
                    return [4 /*yield*/, this.port.close()];
                    case 5:
                        // close the port
                        _a.sent();
                        this.port = null;
                        return [2 /*return*/];
                }
            });
        });
    };
    BrowserSerial.prototype.write = function (cmd) {
        return __awaiter(this, void 0, void 0, function () {
            var writer;
            return __generator(this, function (_a) {
                writer = this.writeToStream.getWriter();
                // write command and unlock
                writer.write(cmd + this.EOF);
                writer.releaseLock();
                return [2 /*return*/];
            });
        });
    };
    BrowserSerial.prototype.readLoop = function (callable) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, done, value, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.port.readable) return [3 /*break*/, 8];
                        // lock the reader to the port stream loop
                        this.reader = this.readFromStream.getReader();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, 6, 7]);
                        _b.label = 2;
                    case 2:
                        if (!true) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.reader.read()];
                    case 3:
                        _a = _b.sent(), done = _a.done, value = _a.value;
                        // if no more values, break
                        // FYI done seems to always return false...
                        done = callable(value, done);
                        console.log(done);
                        if (done === true) {
                            console.log("breaking");
                            return [3 /*break*/, 4];
                        }
                        return [3 /*break*/, 2];
                    case 4: return [3 /*break*/, 7];
                    case 5:
                        e_1 = _b.sent();
                        console.log("ERROR, ", e_1);
                        return [3 /*break*/, 7];
                    case 6:
                        console.log("unlocking reader");
                        console.log("before unlock");
                        this.reader.releaseLock();
                        console.log("after unlock");
                        this.reader = null;
                        console.log(this.reader);
                        return [7 /*endfinally*/];
                    case 7: return [3 /*break*/, 0];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    // assumes that the stream reads line by line
    BrowserSerial.prototype.readUntilLine = function (until, reader, callable) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, done, value, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 4, 5, 6]);
                        _b.label = 1;
                    case 1:
                        if (!true) return [3 /*break*/, 3];
                        return [4 /*yield*/, reader.read()];
                    case 2:
                        _a = _b.sent(), done = _a.done, value = _a.value;
                        // if no more values, break
                        // FYI done seems to always return false...
                        callable(value, done);
                        if (value === until) {
                            console.log("breaking");
                            return [3 /*break*/, 3];
                        }
                        return [3 /*break*/, 1];
                    case 3: return [3 /*break*/, 6];
                    case 4:
                        e_2 = _b.sent();
                        console.log("ERROR, ", e_2);
                        return [3 /*break*/, 6];
                    case 5:
                        reader.releaseLock();
                        return [7 /*endfinally*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    // assumes that the stream reads line by line
    BrowserSerial.prototype.readUntil = function (until, callable) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, done, value, e_3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.port.readable) return [3 /*break*/, 8];
                        this.reader = this.readFromStream.getReader();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, 6, 7]);
                        _b.label = 2;
                    case 2:
                        if (!true) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.reader.read()];
                    case 3:
                        _a = _b.sent(), done = _a.done, value = _a.value;
                        // if no more values, break
                        // FYI done seems to always return false...
                        callable(value, done);
                        if (value === until) {
                            console.log("breaking");
                            return [3 /*break*/, 4];
                        }
                        return [3 /*break*/, 2];
                    case 4: return [3 /*break*/, 7];
                    case 5:
                        e_3 = _b.sent();
                        console.log("ERROR, ", e_3);
                        return [3 /*break*/, 7];
                    case 6:
                        console.log("unlocking reader");
                        console.log("before unlock");
                        this.reader.releaseLock();
                        console.log("after unlock");
                        this.reader = null;
                        console.log(this.reader);
                        return [7 /*endfinally*/];
                    case 7: return [3 /*break*/, 0];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    BrowserSerial.prototype.readAllChunks = function (readableStream) {
        var reader = readableStream.getReader();
        var chunks = "";
        return pump();
        function pump() {
            return __awaiter(this, void 0, void 0, function () {
                var _a, value, done;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, reader.read()];
                        case 1:
                            _a = _b.sent(), value = _a.value, done = _a.done;
                            if (done) {
                                return [2 /*return*/, chunks];
                            }
                            chunks += value;
                            return [2 /*return*/, pump()];
                    }
                });
            });
        }
    };
    BrowserSerial.prototype.readGenerator = function () {
        return __asyncGenerator(this, arguments, function readGenerator_1() {
            var _a, value, done, e_4;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.port.readable) return [3 /*break*/, 10];
                        this.reader = this.readFromStream.getReader();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 7, 8, 9]);
                        _b.label = 2;
                    case 2:
                        if (!true) return [3 /*break*/, 6];
                        return [4 /*yield*/, __await(this.reader.read())];
                    case 3:
                        _a = _b.sent(), value = _a.value, done = _a.done;
                        return [4 /*yield*/, __await({ value: value, done: done })];
                    case 4: return [4 /*yield*/, _b.sent()];
                    case 5:
                        _b.sent();
                        if (done === true) {
                            console.log("breaking!");
                            return [3 /*break*/, 6];
                        }
                        return [3 /*break*/, 2];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_4 = _b.sent();
                        console.log("ERROR, ", e_4);
                        return [3 /*break*/, 9];
                    case 8:
                        console.log("unlocking reader");
                        this.reader.releaseLock();
                        return [7 /*endfinally*/];
                    case 9: return [3 /*break*/, 0];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    BrowserSerial.prototype.getReader = function () {
        if (this.port.readable) {
            return this.readFromStream.getReader();
        }
    };
    // test out the generator
    BrowserSerial.prototype.readLineGenerator = function () {
        return __asyncGenerator(this, arguments, function readLineGenerator_1() {
            var _a, value, done, e_5;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.port.readable) return [3 /*break*/, 10];
                        this.reader = this.readFromStream.getReader();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 7, 8, 9]);
                        _b.label = 2;
                    case 2:
                        if (!true) return [3 /*break*/, 6];
                        return [4 /*yield*/, __await(this.reader.read())];
                    case 3:
                        _a = _b.sent(), value = _a.value, done = _a.done;
                        return [4 /*yield*/, __await({ value: value, done: done })];
                    case 4: return [4 /*yield*/, _b.sent()];
                    case 5:
                        _b.sent();
                        if (done === true) {
                            console.log("breaking!");
                            return [3 /*break*/, 6];
                        }
                        return [3 /*break*/, 2];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_5 = _b.sent();
                        console.log("ERROR, ", e_5);
                        return [3 /*break*/, 9];
                    case 8:
                        console.log("unlocking reader");
                        this.reader.releaseLock();
                        return [7 /*endfinally*/];
                    case 9: return [3 /*break*/, 0];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    return BrowserSerial;
}());
exports.BrowserSerial = BrowserSerial;
var LineBreakTransformer = /** @class */ (function () {
    function LineBreakTransformer() {
        this.container = "";
    }
    LineBreakTransformer.prototype.transform = function (chunk, controller) {
        this.container += chunk;
        var lines = this.container.split("\r\n");
        var pop = lines.pop();
        this.container = "";
        if (pop) {
            this.container = pop;
        }
        lines.forEach(function (line) { return controller.enqueue(line); });
    };
    LineBreakTransformer.prototype.flush = function (controller) {
        controller.enqueue(this.container);
    };
    return LineBreakTransformer;
}());
